#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
## Reading Files

# In programming, we work with files all the time. It's such a useful task that most programming languages have the ability to work with files baked into the core set of features.
# Python is no exception. It gives us file objects which we can use to read and write to files. To open a file on a computer called spider.txt, we can write this code.

file = open("spider.txt")

# What we're doing here is creating a new file object and assigning it to a variable called File. The parameter we've passed to the open function is the name of the file we want 
# to open. In this case, we're assuming the file we want to read is in the same directory as a script we're running but we can just as easily pass an absolute paths to open a 
# file in a different directory. When we open a file, like we're doing in this example, the operating system checks that we have permissions to access that file and then gives 
# our code a file descriptor. This is a token generated by the OS that allows programs to do more operations with the file. In Python, this file descriptor is stored as an 
# attribute of the files object. The file object gives us a bunch of methods that we can use to operate with the file. Now, with this file object, we can read the contents of 
# the file and print them to the screen.

print(file.readline())
# The itsy bitsy spider climbed up the watersprout.

# Each time we call the readline method, the file object updates the current position in the file. So it keeps moving forward. We can also call the read method, which reads from 
# the current position until the end of the file instead of just one line

print(file.read())
# The itsy bitsy spider climbed up the watersprout.

# Both methods read from the current position. The readline() method reads one line, while read() reads until the end of the file.

# Finally, we close the file using the close method.

fiel.close()

# This open-use-close pattern is a typical way of working with files in most programming languages. It's a good idea to close files after you've opened them for a few reasons. 
# First, when a file is opening your script, your file system usually lock it down and so no other programs or scripts can use it until you're finished. 
# Second, there's a limited number of file descriptors that you can create before your file system runs out of them. Although this number might be high, it's possible to open a
# lot of files and deplete your file system resources. This can happen if we're opening files in a loop, for example. 
# Third, leaving open files hanging around can lead to race conditions which occur when multiple processes try to modify and read from one resource at the same time and can 
# cause all sorts of unexpected behavior.

# So to help us remember to close the file after at the we're done using it, Python lets us create a block of code by using the keyword "with
with open("spider.text) as file:
          print(file.readline())

# When we use a "with" block, Python will automatically close the file. So we don't need to remember to do that ourselves. One last thing to think about, thanks Python. 
# Both the open-use-close approach and the "with" approach have their advantages. 
# Using a "with" block is a good way to open and work on a single file then have the file automatically closed at the end of the block. On the flip side, 
# using open outside of a block means we can use a file object in other places in our code. So we're not restricted to just one single block. But when taking this approach, 
# we need to remember to close it when we're finished
#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
## Iterating through Files

# File objects can be iterated in the same way as other Python sequences like list or strings. This is really useful when you want to process a file line by line. 
# Say for example you want to make a whole line uppercase before printing it. You can do that with something like this.
          
 with open("spider.text) as file:
           for line in file:
                 print(line.upper())
  
# THE ITSY BITSY SPIDER CLIMBED UP THE WATERSPROUT
 
 # code snippet will correctly open a file and print lines one by one without whitespace
 with open("hello_world.txt") as text:
    for line in text:
	    print(line.strip())
           
# Another way we can work with the contents of the file is to read the file lines into a list. Then, we can do something with the lists like sort contents. 
# To do that, we open the file and use the.readlines method. Let's see how that looks. 
           
# First, we open the file.
file = open("spider.txt")
           
# Then, read all the lines.
lines = files.readline()
           
# Now, we close the file.
file.close()

# Even though the file object is now closed, the lines variable has the list of lines in the file, so we can operate on it. For example, let's sort it and print it.
lines.sort()
print(lines)
# ['Down came the rain\n', 'Out came the sun\n', 'The itsy bitsy spider climbed up the watersprout\n']
           
 # There are two things to check out on this code. First, the lines have been sorted alphabetically, so they're no longer in the order that they were in the file. 
 # Second, we can see that Python displays a newline character using "\n" symbol when printing a list of strings. This is a way of explicitly showing that there's a 
 # new line character in those strings. In general, to display a character that's not printable, Python uses escape sequences with backslash, like \n. 
 # Another common escape sequence is \t, for tab. We can also use it for escaping quotes, if we have a string that contains either a single or double quote. 
 # A quick word of caution, methods like read or readlines that read the whole file at once are useful, but we should be careful when reading the entire contents of a 
 # file into a variable of our programs. If the file is super large, it can take a lot of our computer's memory to hold it, which can lead to poor performance. 
 # If a file is just a few kilobytes like in our example here, it's fine to read it and process it completely in memory. But for large files, like the big log file of 
 # hundreds and hundreds of megabytes of data, it's more efficient to process it line by line.
#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
## Writing Files
 
with open("novel.txt", "w") as file:
           file.write("It was a dark and stormy night")
           
# File objects can be opened in several different modes. A mode is similar to a file permission. It governs what you can do with the file you've just opened. 
# By default, the open function uses the r mode, which stands for read only. You get an error if you try to write to a file opened in read only mode. Since read only is the 
# default, we don't have to pass the R as a second argument when we just want to read the file. Writing however is a whole different story. The w character tells the open 
# function that we want to open the file for writing only. If the file doesn't exist then Python will create it. If the file does exist, then its current contents will be
# overwritten by whatever we decide to write using our scripts. It's important to remember that when opening a file in write only mode, you can't read its contents. 
# If you try to, the interpreter raises an error. If you want to add content to a file that already exist, you can do that by using other modes like a for appending content at 
# the end of an existing file. Or r+ for read-write mode, where you can both read contents and overwrite it. This has tripped up a lot of us more than once. 
# So I'll say this again. If you open a file for writing and the file already exists, the old contents will be deleted as soon as the file is opened. 
# Yikes, imagine accidentally deleting important content in a file. So remember, double check that you're opening the right file using the right mode.
# if you're generating a report and wants to write it out to a new file using the write, w mode, you probably want to check if the file exists, to avoid losing any previous contents
# Along with read only, write, append, and read-write, the open function supports a bunch of other modes. 
# You'll find all the documentation on this in the official reference, which we'll link to in the next reading
           
# Reading and Writing Files Cheat-Sheet
# Check out the following link for more information:

# https://docs.python.org/3/library/functions.html#open
#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
